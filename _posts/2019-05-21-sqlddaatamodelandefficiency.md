---
title: " SQLD 핵심 정리 - 데이터 모델과 성능"
date: 2019-05-20
categories: sqld
tags: 
  - sqld
  - 데이터모델성능
---

** 현재 작성중이며 임시 저장 상태 입니다. **

# 데이터 모델과 성능

## 성능데이터 모델링이란?
 - 데이터베이스의 성능 향상을 위해 설계단계의 데이터 모델링 때부터 성능과 관련된 사항이 모델링에 반영 될 수 있도록 하는것.
 
 - 데이터의 증가가 빠를수록 성능 저하에 따른 성능개선 비용 증가
 
 - 데이터 모델은 성능을 튜닝하면서 변경이 될 수 있다.
 
 - 분석/설계 단계에서 성능을 고려한 데이터 모델링을 수행 할 경우 성능 저하에 따른 Rework 비용을 최소화 할 수 있다. (빨리 잡기)
 
 - 성능이 저하되면 안되는 트랜잭션이라면, 미리 테스트 환경을 구축하여 테스트 하며 어떤 데이터 모델의 구조가 해당 사이트에 성능상 가장 적절한 구조인지 검토하여 성능이 좋은 모습으로 디자인 해야 한다.
 

## 성능 데이터 모델링 수행 절차 (**순서중요**)
 1) 데이터 모델링을 할 때 정규화를 정확하게 수행해야 한다.
 
 2) 데이터베이스 용량 산정을 수행한다.
 
 3) 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.
 
 4) 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.
 
 5) 이력모델의 조정, PK/FK(기본키,외래키)조정, 슈퍼타입/서브타입 조정(물리적) 등을 수행한다.
  
   **이력데이터**는 시간에 따라 반복적으로 발생 -> 특별히 성능을 고려해 칼럼 등 추가 설계 필요
 
 6) 성능관점에서 데이터모델을 검증한다. (정량 트반 이검)
 
## 데이터 베이스 정규화
 - 목적 : 불필요한 데이터(data redunduncy) 제거 / 데이터 저장을 논리적으로
 - 정규화 순서 
 ```
 - 1차 정규화 : 도메인이 원자값 이어야 한다. 

 - 2차 정규화 : 부분적 종속 해결
 
 ( A - B - C 로 이루어진 것을 A - B / A = C 로 표를 나눔. A + B 가 합쳐져야 기본키인데 C가 A에만 종속되어있어서)
 
 - 3차 정규화 : 이행적 함수 종속 제거 
 
 ( A - B - C  로 이루어진 것을 A -B / B - C 로 표를 나눔 . B에 따라 C가 바뀌는 경우 )
 
 - BCNF : 모든 결정자가 후보키 집합에 속한 것 제거
 ( A - B - C 로 이루어진 것을 A - B / B - C 로 표를 나눔. B에 따라 C가 바뀌지는 않지만, B와 C 의 관계가 바뀔 수 있음. )
 
 - 4차 정규화 : 다치 종속 제거
  ( A - B - C 로 이루어 진 것을 A - B  / A - C 로 표를 나눔. B와 C는 서로 관계가 없지만, A와B, A와C 가 연관있음)
  
 - 5차 정규화 : 조인 종속성 이용
  ( A - B - C 로 이루어 진 것을 A - B / B - C / C - A 로 표를 나눔. A,B,C가 다 서로 연관이 있음. 이것을 나눈것을 다시 조인 시 원래의 형태가 나오도록)
  
 ## 반정규화
  성능을 향상시키기 위해 정규화된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 과정. 데이터의 무결성이 깨질 수 있는 위험을 무릅쓰고 데이터를 중복하여 반정규화
   하는 이유는 데이터를 조회할 때 디스크 I/O 양이 많아서 성능이 저하되거나 경로가 너무 멀어 조인으로 인한 성능 저하가 예상되거나
    칼럼을 계산하여 읽을 떄 성능이 저하될 것이 예상되는 경우 진행. 
    
 ## 반정규화 고려 요소
  1) 반정규화 정보에 대한 재현의 적시성으로 판단. ex) A는 여러 테이블에 대해 다량의 조인이 필요함으로, 적시성 확보를 위해 반정규화
  
  2) 데이터 크기가 크다고 반정규화 할 필요 없이, 파티션, 데이터 클러스터링 등의 다양한 물리 저장 기법 활용. 그러나 하나의 결과셋을 위해 다량의 데이터를 탐색
  하는 일이 반복적으로 빈번하게 일어나면 반정규화 고려
  
  3) 관계형 데이터 베이스 시스템은 이전, 이후의 레코드 탐색은 window function으로 가능함으로 그 이유로 반정규화는 할 필요 없다.
  
  4) 다수 테이블의 키 연결 테이블, 집계 테이블 등 필요할땐 반정규화 한다.
  
 ## 테이블의 반정규화 
  1) 테이블 병합
  
   - 1:1 , 1: M , 슈퍼/서브타입 테이블 병합 하여 성능 향상
   
  2) 테이블 분할
  
   - 수직 분할 : 칼럼 단위 테이블을 디스크 I/O를 분산 처리 위하여 1:1 로 분할
   
   - 수평 분할 : 로우 단위 테이블에서 집중하여 트랜잭션 일어나는 부분을 쪼개어 디스크 I/O 및 데이터 접근성을 높임
   
  3) 테이블 추가
  
   - 중복테이블 추가 : 다른 업무거나 서버가 다르지만 원격으로 사용시 빠르게 하기 위해 중복 테이블 생성
   
   - 통계 테이블 추가 : SUM, AVERAGE 같이 한꺼번에 여러개를 계산해야하고 자주 해야 할 경우 추가
   
   - 이력 테이블 추가 : 이력성 정보 조회를 위해 생성. 
   
   - 부분 테이블 추가 : 자주 이용하는 칼럼 등의 부분을 추가. ( 테이블 분할은 아에 분할, 얘는 중복으로 추가 )
   
 
 ## 칼럼의 반정규화
  - 중복칼럼 추가 : 갱신보다 조회만 하는 게 더 중요할 경우 중복된 칼럼 추가. (조인 할 필요가 없어짐. 대신 갱신 비용 증가)
  
  - 파생칼럼 추가 : 계산 칼럼 추가 ( 트랜 잭션이 발생하는 시점에 계산에 의한 성능 저하 방지)
  
  - 이력테이블 칼럼 추가 : 변경 이력, 발생 이력 정보를 위한 최신 정보 컬럼 추가
  
  - PK에 의한 칼럼 추가 : PK의 속성을 일반속성으로 추가하여 연산 줄임
  
  - 응용시스템 오작동을 위한 칼럼 추가  : 벡업용 데이터 칼럼 추가
  
  
## 로우 체이닝, 로우 마이그레이션
 1) 로우 체이닝 
  - 로우가 너무 많아 두개 이상의 블록에 걸쳐 하나의 로우가 저장 되어 있는 상태
  
 2) 로우 마이그레이션
  - 블록에서 수정이 되었는데 너무 많아 담지 못하여 다른 블록에 저장 하는것
  
## 파티셔닝
 - 하나의 테이블에 많은 양의 데이터가 저장되면, 인덱스 추가와 테이블을 몇 개로 쪼개도 성능이 저하됨. 
  이떄 논리적으로는 하나의 테이블이지만, 물리적으로는 여러개의 테이블로 분리하는것. 컴퓨터 파티션과 같음
  
## 슈퍼타입 - 서브타입 데이터 모델 변환 기술
 - 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성
 - 슈퍼타입 + 서브타입에 대해 발생되는 트랜잭션에 대해서는, 슈퍼타입+서브타입 테이블로 구성
 - 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성
 
 
**남은 부분은 sql 파트 진행 후 마저 써 가겠습니다.**
  
  
  
  
  
