---
title: "[BOJ] 백준 17288 3개만! 코드 C++"
date: 2019-07-02
categories: 
  - 백준
tags: 
  - 백준
  - C++
  - 완전탐색
---

# 문제 정보
백준 ( BOJ ) 17288번 3개만!

문제 풀이 : 완전탐색

문제 출처 : 경찰대학 > 2019 ChickenReallyGood 대회 F번

문제 링크 : https://www.acmicpc.net/problem/17288

# 문제 풀이 
문제에서 빠진 조건이 있는데,

연속한 수라는 것은 123 처럼 오름차순이지, 321 처럼 내림차순은

연속한 수 가 아닙니다. 

아마 나중에 문제가 고쳐질 것 같습니다. 

문제의 조건은 간단합니다. 

연속하는 수가, 딱 3개로 떨어지는

즉, 123은 연속한수, 1234, 0123 은 연속한 수가 아닙니다. 

각각 탐색하면서, 

최대값-3까지 3개단위로 검사를 하고

만약 3개단위로 연속한수라면 

4번째가 연속한 수인지 아닌지 판단합니다. 

그리고 4번째가 연속한 수라면

그뒤로 쭉~ 연속한 수를 건너뛰고

만약 4번쨰가 연속한 수가 아니면 카운터를 한개 늘려주면 됩니다. 

만약 저렇게 안한다면,

123456 을 검사할때

123을 검사하고, 4를 봤을때 연속한수가 아님으로

넘어가 놓고

456만 보고 연속한수 갯수를 카운트 할 겁니다.

만약 맞게 풀었다고 생각을 했는데, 틀린 답이라고 나온다면

대부분 12345, 123456, 123456789 처럼 연속한 수를 여러개 늘어트려 놓았을때 

오답이 나올겁니다.


# 코드
```
#include <iostream>
#include <string>

using namespace std;


int main() {
	string a;
	int result = 0;
	int counter = 0;
	int checker = 0;
	cin >> a;

	for (int i = 0; i < a.size()-2; i++) {
		if (a.at(i) + 1 == a.at(i + 1) && a.at(i + 1) + 1 == a.at(i + 2)) {
			if (i + 3 < a.size()  && (a.at(i + 2) + 1 == a.at(i + 3))) {

				while (i < a.size()-1 && a.at(i) + 1 == a.at(i + 1)) {
					i++;
				}
			}
			else
				result++;
		}
	}
	cout << result;
	return 0;
}
```
